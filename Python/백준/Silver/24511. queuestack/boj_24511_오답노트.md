# 백준 24511번 - Queuestack 오답노트

## 문제 정보
- **문제 번호**: 24511
- **문제 제목**: Queuestack
- **난이도**: 실버 3

## 오답 코드 분석

### ❌ 내가 제출한 코드
```python
for i in range(M):
    integer = C[i]
    for j in range(N):
        if A[j] == 0:
            B[j], integer = integer, B[j]
    print(integer, end=" ")
```

### ✅ 정답 코드
```python
queue = deque([])
for i in range(N):
    if A[i] == 0:
        queue.append(B[i])

for i in range(M):
    queue.appendleft(C[i])
    print(queue.pop(), end=' ')
```

## 오답 원인 분석

### 1. 시간 복잡도 문제
- **내 코드**: `O(M × N)` 
  - M=100,000, N=100,000일 때 최악의 경우 100억 번 연산 → **시간 초과**
- **정답 코드**: `O(N + M)`
  - 초기에 O(N)으로 큐 원소만 추출
  - 이후 O(M)만큼 deque 조작

### 2. 불필요한 스택 처리
- 문제에서 **스택은 무시하고, 큐만 남아있다고 생각해도 된다**는 점을 놓쳤음
- 내 코드는 매 삽입마다 B 배열을 계속 수정하면서 불필요한 연산을 반복

### 3. 큐 동작 시뮬레이션의 핵심 누락
- **A[i] == 0**인 곳(큐)에 있는 원소들만 최종 결과에 영향을 미친다
- 따라서 큐인 B[i]만 추려내서, 그 큐에 대해 `appendleft`, `pop` 조작만 하면 됨

## 핵심 교훈

| 구분 | 내용 |
|------|------|
| **자료구조 이해** | 문제에서 큐만 남아 있는 상태로 동작한다고 생각해야 빠르게 해결할 수 있음 |
| **시간복잡도 고려** | 반복문 2중 구조는 최대 입력값에서 절대 피해야 함 |
| **상태 유지 방식** | 기존 배열을 계속 업데이트하는 방식보다는 deque 등으로 시뮬레이션 상태를 유지하는 것이 더 효율적 |

## 요약
- ❗ **내 코드 문제**: `O(M×N)` 반복 → 시간 초과
- ✅ **정답 핵심**: 큐만 남기고 deque 시뮬레이션
- 💡 **앞으로 주의할 점**: 문제 조건 중 "스택 무시 가능", "상태 유지", "입력 범위 크기"를 꼭 확인하자

## 해결 과정
1. **A[i] == 0**인 인덱스에 해당하는 **B[i]** 값들만 deque에 저장
2. 매 연산마다 **C[i]**를 deque의 앞쪽에 삽입(`appendleft`)
3. deque의 뒤쪽에서 원소를 제거(`pop`)하여 출력
