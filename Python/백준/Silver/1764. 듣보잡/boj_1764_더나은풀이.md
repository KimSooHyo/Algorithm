
## 🔷 1. set으로 푸는 방법 정리

### 💡 문제 개요

* 듣도 못한 사람 `N명`, 보도 못한 사람 `M명`
* 두 명단의 \*\*공통된 이름(듣보잡)\*\*을 찾아 **사전순 정렬** 후 출력

### ✅ set 풀이 코드

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())

listen = set(input().strip() for _ in range(N))
see = set(input().strip() for _ in range(M))

result = sorted(listen & see)  # 교집합 & 정렬

print(len(result))
print('\n'.join(result))
```

### ✅ 시간 복잡도

* `listen` 만들기: O(N)
* `see` 만들기: O(M)
* `listen & see`: O(min(N, M)) (해시 기반 비교)
* 정렬: O(K log K) (K = 교집합 크기)

> **총합: O(N + M + K log K)** → 매우 빠름

---

## 🔶 2. dict로 푸는 방법과 비교

### 📌 dict 방식 요약

```python
name_dict = {}
for _ in range(N + M):
    name = input().strip()
    name_dict[name] = name_dict.get(name, 0) + 1

result = sorted([name for name, count in name_dict.items() if count == 2])
```

### 📌 시간 복잡도

* dict 삽입: O(N + M)
* dict 필터링: O(N + M)
* 정렬: O(K log K)

> **총합: O(N + M + K log K)** → 이론상 set과 유사하지만,
> 실제로는 `dict.items()` 처리나 가독성 측면에서 **set보다 불리함**

---

## 🔷 3. 이 문제에서 set이 더 좋은 이유

| 비교 항목        | set 사용                 | dict 사용            |
| ------------ | ---------------------- | ------------------ |
| **중복 제거 여부** | 자동 (set은 중복 허용 안 함)    | 직접 처리해야 함          |
| **교집합 연산**   | `A & B`로 한 줄 처리        | 두 번 등장한 이름 직접 확인해야 |
| **코드 간결성**   | ✅ 훨씬 깔끔                | ❌ if/else, 필터링 필요  |
| **성능 최적화**   | 해시 기반 교집합 연산 최적화       | dict 순회, 카운팅 필요    |
| **문제 조건 부합** | ✅ 이름이 중복되지 않음 → set 적합 | 가능은 하지만 과함         |

---

## 🔶 4. 내가 놓칠 수 있었던 부분

| 놓치기 쉬운 포인트    | 설명                                          |
| ------------- | ------------------------------------------- |
| "교집합"이 핵심 키워드 | 문제 자체가 "듣보잡 = 듣도 못했고, 보도 못한 사람" → 두 집합의 교집합 |
| `set`의 장점     | 중복 자동 제거, 교집합/합집합/차집합 같은 연산 최적화             |
| 문제 조건 이용 안 함  | "이름은 중복되지 않는다" → dict에 굳이 카운트할 필요 없음        |
| 가독성과 목적의 일치   | set은 교집합 연산으로 문제 의도를 그대로 표현함                |

---

## ✅ 5. 어떤 조건에서 set/dict를 써야 하나?

| 상황                     | 추천 자료구조 | 이유                  |          |
| ---------------------- | ------- | ------------------- | -------- |
| 중복 제거가 필요할 때           | `set`   | 자동 중복 제거, O(1) 삽입   |          |
| 두 리스트의 교집합/합집합/차집합     | `set`   | 집합 연산자 지원 (`&`, \`  | `, `-\`) |
| 등장 횟수를 세야 할 때          | `dict`  | key → count 형태로 저장  |          |
| 고유 key에 대한 값 저장이 필요할 때 | `dict`  | 예: 이름 → 나이, 제품 → 가격 |          |
| 어떤 값의 존재 여부만 확인할 때     | `set`   | 해시 기반으로 O(1) 탐색     |          |

---

## ✅ 최종 요약

* 이 문제에서는 `중복 없는 문자열`로 구성된 두 목록의 **교집합**을 찾는 문제 → **set이 최적**
* `dict`는 **카운트나 추가 정보 저장**이 필요할 때 사용
* `set`은 간결하고 문제의 목적(교집합 탐색)을 정확하게 표현할 수 있음
* 시간복잡도는 거의 유사하지만, `set`은 연산이 더 최적화되어 있고 코드도 더 짧고 명확

---

